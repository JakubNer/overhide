# Glossary & Notation

## Notation

###### F(X)

Function of *X*:  *X* is used in generation of result from *F*.

###### A ◠ B

*A* is concatenated with *B*.

###### x-key<sub>pub</sub>

*x-key* is used as a public key in a private-public pair.

###### x-key<sub>priv</sub>

*x-key* is used as a private key in a private-public pair.

###### x-key<sub>sym</sub>

*x-key* is used as a key for symmetric encryption/decryption.

###### name<sub>sig</sub>(x-key<sub>priv</sub>)

*name* is signed with *x-key<sub>priv</sub>*.  *name* can be checked against *name<sub>sig</sub>(x-key<sub>priv</sub>)* by using *x-key<sub>pub</sub>*.

###### name<sub>hash</sub>

Hash of *name*.

## Definitions

Definitions below are not in alphabetic order but ordered increasing in specificity to our system.  

For example a *member-channel* is a function of *user-key*: F(user-key). which is an instance of *datastore-key*.  As such these are defined in the order *datastore-key* first, then *user-key*, then *member-channel*.

> **service, user, group, group-owner, member**
>
> These terms are not part of the *overhide* system, which is really just a datastore with
> secrets, keys, values, and queues.  These terms aid in thinking about use cases.
>
> See the [About](../README.md) section of the *overhide* [README.md](../README.md) for
> context on these terms.
>
> **service** :: software using *overhide* to provide value to user.
> <br/>**user** :: individual entity holding data in the system.
> <br/>**group** :: collection of users sharing data via system.
> <br/>**group-owner** :: user congealing a group together.
> <br/>**member** :: user in context of belonging to a group.

###### secrets

Secrets are an array of private-public key pairs obtained from a 12 word mneumonic using the BIP39 algorithm.

Secrets can be per user, per service, per group, whatever the domain calls for.

*secrets* is an array, *secrets[0]* would be the first key pair of *secrets[0]<sub>pub</sub>* and *secrets[0]<sub>priv</sub>*.  Keys from *secrets* can be used for anything in the system.

###### broker

The "broker"--abstracted via the broker API--uses secrets to store and provide users' data.

The broker is a key-value datastore with simplistic CRUD data operations.

The broker doesn't enforce that the keys nor values are encrypted.  This mechanism of *override* is by convention: it's what makes sense.

The keys have an additional property of being a queue as a backchannel.

###### domain-key

In a key-value store values are retrieved using human readable keys.  Keys that have some domain specific meaning, prefixed and suffixed in domain meaningful ways.

These domain human readable keys are referred to as *domain-keys* in our writeups.

###### datastore-key

*F(domain-key)<sub>hash</sub>*

In *overhide* the *datastore-key* is a non human-readable hash that is some function of the domain-key.

Each datastore-key is 64 bytes long.

Each datastore-key is expected to be 2 SHA256 hashes.  The idea being that a concatenation of 2 hashes reduces already miniscule chance of conflict.

###### datastore-value

Each datastore-value is somehow encrypted.  Details of encryption depend on service needs and service's internal contract.  E.g. *user-secret* encrypted for *user-key*, *private-key* encrypted with *group-secret* for *group-key*.

###### user-key

An type of a *datastore-key*.

A *datastore-key* (64 bytes/2 hashes) with the first SHA256 hash (32 bytes) being concatenation of *user-key* and some domain specific key:  *(user-key◠key)<sub>hash</sub>*.  The second SHA256 hash (32 bytes) being some other key *key'<sub>hash</sub>* where *key'* is either a different domain specific key or same key from the first hash.

###### group-key

An type of a *datastore-key*.

A *datastore-key* (64 bytes/2 hashes) with the first SHA256 hash (32 bytes) being some public-key generated by *group-owner*.  The second SHA256 hash (32 bytes) can be null, all zeroes, 0x0000..0000.
